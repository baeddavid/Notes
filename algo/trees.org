#+TITLE: Algorithms
#+DESCRIPTION: Notes on algorithms and my pseudocodes for exercises

* Algo Notes
** Trees
*** Traversals
**** Three main ways to traverse a tree
***** Inorder Traversal
#+BEGIN_SRC java
void inorder(Node root) {
    if(root != null) {
        inorder(root.left);
        System.out.print(root.data);
        inorder(roof.right);
    }
}
#+END_SRC
We can traverse the tree iteratively if we use a stack
#+BEGIN_SRC java
void inorder(Node root) {
    Stack <Node> s = new Stack <>();
    s.push(root);
    Node curr = root;

    while(!s.isEmpty() || curr != null) {
        while(curr != null) {
            s.push(curr);
            curr = curr.left;
        }
        curr = s.pop();
        System.out.print(curr.data);
        curr = curr.right;
    }
}
#+END_SRC
***** Preorder Traversal
#+BEGIN_SRC java
void preorder(Node root) {
    if(root != null) {
        System.out.print(root.data);
        preorder(root.left);
        preorder(root.right);
    }
}
#+END_SRC
***** Postorder Traversal
#+BEGIN_SRC java
void postorder(Node root) {
    if(root != null) {
        postorder(root.left);
        postorder(root.right);
        System.out.print(root.data);
    }
}
#+END_SRC
*** Search
Due to the nature of binary search trees, searching for an element is a fast operation taking only O(n log n) time.
This too can be done either recursively or iteratively.
**** Recursive
#+BEGIN_SRC java
Node search(Node root, int key) {
    if(root == null || key = root.data) {
        return root;
    }

    if(key < root.data) {
        return search(root.left, key);
    } else {
        return search(root.right, key);
    }
}
#+END_SRC
**** Iterative
#+BEGIN_SRC java
Node search(Node root, int key) {
    while(root != null && root.data != key) {
        if(root.data < key) {
            root = root.right;
        } else {
            root = root.left;
        }
    }
    return root;
}
#+END_SRC
*** Min and Max
Due to the sorted nature of binary search trees we can find minimum and maximum values fairly easily.
**** Minimum
#+BEGIN_SRC java
Node getMinimum(Node root) {
    while(root.left != null) {
        root = root.left;
    }
    return root;
}
#+END_SRC
**** Maximum
#+BEGIN_SRC java
Node getMaximum(Node root) {
    while(root.right != null) {
        root = root.right;
    }
    return root;
}
#+END_SRC
Although the Min and Max operations are fairly straightforward implementations they are useful in finding predecessors or sucessors for nodes.
*** Successor and Predecessors
**** Successor
If all keys in a tree are distinct, the successor of a node x is the node with the smallest key greater than x. The structure of a binary search tree allows us to determine the succssor of a node without even comparing the keys.

There are two ways to find the successor for a node depending on memory.
***** If node has parent attribute
If the node has a parent attribute the implementation is straightforward in that we need to perform two checks. If the node has a right child, we call getMinimum on the right child and return the result.

If the node does not have a right child, we walk up the tree until we reach an ancestor that has the node we called on as a left subtree.
#+BEGIN_SRC java
Node getSuccessor(Node x) {
    if(x.right != null) {
        return getMinimum(x.right);
    } else {
        Node y = x.parent;
        while(y != null && x == y.right) {
            x = y;
            y = y.parent;
        }
        return y;
    }
}
#+END_SRC
***** If the node does not have a parent attribute
If the node does not have a parent attribute we need to be a little bit more clever. What we do instead is pass three parameters into a function. One the root of the tree, one the target, and the last a null value that we will use to store candidates for successors.

If the data at root is equal to the key of the node we want to find the successor and it has a right child we call getMinimum and return its value.

If the data at root is less than the key we recurse leftwards such that root <-- root.left and successor <-- root.

If the data at root is greater than the key we recurse righwards such that root <-- root.right. However we do not reassign successor due to the assignment violating the principle that a successor node is larger than the node we have called it on.

#+BEGIN_SRC java
Node getSuccessor(Node root, Node succ, int key) {
    if(root == null) {
        return null;
    }

    if(root.data == key) {
        if(root.right != null) {
            return getMinimum(root.right);
        }
    } else if(key < root.data) {
        succ = root;
        return getSuccessor(root.left, succ, key);
    } else {
        return getSuccessor(root.right, succ, key);
    }

    return succ;
}
#+END_SRC
*** Insertion and Deletion
**** Insertion
To insert a new value v into a binary search tree T, we use the procedure TREE-INSERT. The procedure takes a node z for which z.key = v, z.left = NIL, and z.right = NIL. It modifies T and some of the attributes of z in such a way that it inserts z into an appropriate position in the tree.

#+BEGIN_SRC java
void TreeInsert(Node root, Node insert) {
    Node y = null;
    Node x = root;

    while(x != null) {
        y = x;
        if(insert.key < x.key) {
            x = x.left;
        } else {
            x = x.right;
        }
    }
    insert.parent = y;
    if(y == null) {
        root = insert;
    } else if(insert.key < y.key) {
        y.left = current;
    } else {
        y.right = insert;
    }
}
#+END_SRC
**** Deletion
The overall strategy for deleting a node z from a binary search tree T has three basic cases.
***** If z has no children
If we have a parent attribute in the node class, we simply modify z.parent such that it no longer points to z. If z does not have a parent attribute then we iterate through the tree with two pointers, one acting as a parent pointer the other acting as the key pointer. When we find the node to be deleted we simply set the parent pointer such that it no longer points to z.
***** If z has one child
Begin with finding the child node z. Since z only has one child we need to simply remove it and append z.child to the parent pointer.
***** If z has two children
If z has two children it is a little more complicated. We begin with finding the in-order successor. Storing the inorder successor, we then recursively delete it from the tree, replacing the current pointer with the value of the successor.
****** Why we use in-order successor
We do not need to necessarily use the in-order succesor or the in-order predecessor as either one will suffice. What is important is that we find a node that is suitable to preserve the order of the binary search tree.

The only two nodes that can replace a node with two children is either the predecessor or successor.
***** Implmenetation
#+BEGIN_SRC java
Node deleteNode(Node root, int key) {
    Node parent = null;
    Node curr = root;

    // Search for the key and set the parent pointer
    while(curr != null && curr.data != key) {
        parent = curr;
        if(key < curr.data) {
            curr = curr.left;
        } else {
            curr = curr.right;
        }
    }

    // If the key is not in the tree just return.
    if(curr == null) {
        return root;
    }

    // If node to be deleted has no children
    if(curr.left == null && curr.right == null) {
        if(curr != root ){
            if(parent.left == curr) {
                parent.left = null;
            } else {
                parent.right = null;
            }
        } else {
            root = null;
        }
    }

    // If the node to be deleted has two children
    else if(curr.left != null && curr.right != null) {
        Node successor = getSuccessor(root, null, curr.data);
        int val = successor.data;
        delete(root, successor.data);
        curr.data = val;
    }

    // If the node to be deleted has one child
    else {
        // Check to see which child it is
        Node child = (curr.left != null) ? curr.left : curr.right;
        if(curr != root) {
            if(curr == parent.left) {
                parent.left = child;
            } else {
                parent.right = child;
            }
        } else {
            root = child;
        }
    }
    return root;
}
#+END_SRC

*** Thoughts on Trees
Take note that of the two operations we have already looked at we are able to use both iterative and recursive implementations. This is due to the recursive nature of the data structure.
*** Exercises
**** 12.2.1 was skipped due to needing the answer to be drawn
**** 12.2.2 Write recursive versions of TREE-MINIMUM and TREE-MAXIMUM
#+BEGIN_SRC java
Node treeMinimum(Node root) {
    if(root.left == null) {
        return root;
    }
    return treeMinimum(root.left);
}

Node treeMaximum(Node root) {
    if(root.right == null) {
        return root;
    }
    return treeMaximum(root.right);
}
#+END_SRC
**** 12.2.3 Write the TREE-PREDECESSOR procedure
Assuming that we have a parent attribute in the node
#+BEGIN_SRC java
Node treePredecessor(Node x) {
    if(x.left != null) {
        return getMaximum(x.left);
    } else {
        Node y = x.parent;
        while(y != null && x == y.left) {
            x = y;
            y = y.parent;
        }
        return y;
    }
}
#+END_SRC

If we don't have access to a parent attribute we do the same as sucessor implementation
#+BEGIN_SRC java
Node treePredecessor(Node root, Node pred, int key) {
    if(root == null) {
        return null;
    }

    if(root.data == key) {
        if(root.left != null) {
            return getMaximum(root.left);
        }
    } else if(key < root.data) {
        return treePredecessor(root.left, pred, key);
    } else {
        pred = root;
        return treePredecessor(root.right, pred, key);
    }
    return pred;
}
#+END_SRC
**** 12.2.5 Show that if a node in a binary search tree has two children then its successor has no left child and it predecessor has no right child.
Assume the we are operating on a node z which has two children. If we are to find the successor i.e. the smallest node that is larger than z, we must traverse down the left subtree for z.right. The successor is the last node in this left subtree. It cannot have a left child, as that would imply that the node we are currently on is not in fact the successor as there is another node that is smaller, but greater than z.

The same logic applies to the predecessor for z. The predecessor is the largest node smaller than it. We can acheive this by traversing the right subtree of z.left. If the "predecessor" has a right child, than we node that the current node we are on is not the predecessor as there is another node that is larger it that is smaller than z.
**** 12.3.1 Give a recursive version of the TREE-INSERT procedure.
The iterative tree insert procedure is simply a modified implementation of the TREE-SEARCH algorithm. Looking at the iterative tree insert implementation, the first step we do is search for the appropriate position of the node.

 #+BEGIN_SRC java
void insert(int data) {
    // Assuming root is a class variable
    TreeNode current = root;
    TreeNode parent = null;
    while(current != null) {
        if(data < current.data){
            parent = current;
            current = current.left;
        } else {
            parent = current;
            current = current.right;
        }
    }
    if(parent.data > data) {
        parent.left = new TreeNode(data);
    } else {
        parent.right = new TreeNode(data);
    }
}
 #+END_SRC


 A recursive implementation of the insert method would change the while loop into a recursive search.
 #+BEGIN_SRC java
void insert(TreeNode root, TreeNode parent, int data) {
    // If the root is null we can insert data into tree.
    if(root == null) {
        if(parent.data > data) {
            parent.left = new TreeNode(data);
        } else {
            parent.right = new TreeNode(data);
        }
    }

    // If the root is not null we set up our recursion
    if(data < root.data) {
        return insert(root.left, root, data);
    } else {
        return insert(root.right, root, data);
    }
}
 #+END_SRC
**** 12.3.2 Suppose that we construct a binary search tree by repeatedly inserting distinct values into the tree. Argue that the number of nodes examined in searching for a value in the tree is one plus the number of nodes examined when the value was first inserted into the tree
As mentioned in the previous answer, the TREE-INSERTION method is a modified implementation of TREE-SEARCH. Because binary search trees are sorted, inserting an element requires us to search for the correct position to insert the new node.

For example given a tree [6,4,12] and we wish to insert the value 5 we must first search for the correct position. Inserting it into tree gives us [6,4,12,null,5] with two comparisons --> 5 < 12 and 5 > 4.

Searching for the value 5 in the tree now requires three comparisons, 5 < 12, 5 > 4, 5 = 5. Why is the number of nodes examined in search for a value one plus the nuymber of nodes examined when it was first inserted?

This is because of the sorted anture of the tree. When we insert a node z into the tree, say we perform x comparisons to find the correct position. Searching for z in the tree immediately after it was inserted into the tree is now x + 1 comparison.
**** 12.3.3 We can sort a given set of n numbers by first building a binary search tree containing these numbers and printing the numbers by an inorder tree walk. What are the worst case and best case running times for this sorting algorithm?
The worst case running time for sorting an array using a binary search tree is O(n^2). This occurs when the input array is sorther either ascending or descending. This is because we must traverse the entire tree to append any element from an array A.

The best case is when the tree is balanced. Insertion into a balanced tree is a O(log n) operation since we only need to traverse a single subtree at each comparison. This means that given a perfectly balanced input, sorting the array would take O(n log n).

** Interview Problems
*** Maximum Depth of Binary Tree
 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node dwon to the farthest leaf node.

 Example: Given binary tree [3,9,20,null,null,15,7] return 3.

 My base instinct is to create a variable called max that will store the height of a tree. I then perform an inorder traversal of the tree keeping track of the maximum depth seen so far. Although this solution would technically work, the implementation is long and potentially messy.

 Instead there is a much more straight forward solution to this problem. Keeping in mind the recursive property of trees, we can call the function on both the left and right subtrees and then add one to the max of the two values.

 #+BEGIN_SRC java
int maxDepth(TreeNode root) {
    // If the root is null return 0.
    if(root == null) {
        return 0;
    }

    // Height of the left subtree
    int L = maxDepth(root.left);
    // Height of the right subtree
    int R = maxDepth(root.right);

    // Return the max of the two subtrees + 1 to account for the root for the two subtrees.
    return Math.max(L, R) + 1;
}
 #+END_SRC
*** Inorder Traversal
Given a binary search tree perform an inorder traversal of the tree.
Extra: Do it without recursion.

The obvious way to do it with recursion is to check if the current treeNode is null or not.
#+BEGIN_SRC java
void inOrder(TreeNode root) {
    if(root != null) {
        inOrder(root.left);
        System.out.print(root.data);
        inOrder(root.right);
    }
}
#+END_SRC

Performing an iterative traversal is a little biut more complicated. When looking at how the inorder traversal walks through a tree you will note that after going down the left most sub tree and printing the left most leaf, we then walk back up the tree. When we walk back up the tree, we check if the treeNode has a right child; if it does we begin traversing this subtree as well. What you will notice is that this is somewhat similar to how a stack works, we use the last node we have, then go back up the tree or "pop" it off the stack.

#+BEGIN_SRC java
void inOrder(TreeNode root) {
    Stack <TreeNode> s = new Stack <>();
    TreeNode current = root;
    s.push(root);

    while(current != null || !s.isEmpty()) {
        while(currnet != null) {
            current = current.left;
            s.push(current);
        }
        current = s.pop();
        System.out.print(s.data);
        current = current.right;
    }
}
#+END_SRC
*** Range Sum of BST
Given the root node of a binary tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values.

Example 1:
I: root = [10,5,15,3,7,null,18], L = 7, R = 15
O: 32

The first thing that comes to mind is use any traversal method to visit each node. If the value of the node is between L and R (inclusive) we add it to the sum. When we have finished traversing the tree, we return the sum.

#+BEGIN_SRC java
// Recursive implementation

// Class variable
int sum = 0;
int rangeSum(TreeNode root, int L, int R) {
    return getSum(root, sum, L, R);
}

void getSum(TreeNode root, int L, int R) {
    if(root != null) {
        getSum(root.left, L, R);
        if(L <= root.data && root.data <= R) {
            sum += root.data;
        }
        getSum(root.right, L, R);
    }
}
#+END_SRC

We can also do the same with an iterative tree traversal using a stack
#+BEGIN_SRC java
int rangeSum(TreeNode root, int L, int R) {
    Stack <TreeNode> s = new TreeNode <>();
    TreeNode current = root;
    int sum = 0;

    while(current != null || !s.isEmpty()) {
        while(current != null) {
            s.push(current);
            current = current.left;
        }
        current = s.pop();
        if(L <= current.val && current.val <= R) {
            sum += current.val;
        }
        current = current.right;
    }
    return sum;
}
#+END_SRC
*** Merge Two Sorted Lists
Consider two singly linked lists in which each node holds a number. Assume the lists are sorted. The merge of the two lists is a list consisting of the nodes of the two lists in which numbers appear in ascending order.

Similar to how we merge two sorted arrays, we use two pointers one for the L1 (list 1) and L2 (list 2). We iterate through the lists. We take the node with the smaller value and advance the pointer up by one. When we have reached the end of one list we append the remaining list to the end.

#+BEGIN_SRC java
Node mergeList(Node L1, node L2) {
    Node newHead = new Node(0);
    Node newCurr = newHead, curr1 = L1, curr2 = L2;

    while(curr1 != null && curr2 != null) {
        if(curr1.data < curr2.data) {
            newCurr.next = curr1;
            curr1 = curr1.next;
        } else {
            newCurr.next = curr2;
            curr2 = curr2.next;
        }
        newCurr = newCurr.next;
    }

    newCurr.next = curr1 == null ? curr2 : curr1;
    return newHead.next;
}
#+END_SRC
*** Reverse a Single Sublist
Write a program which takes a singly linked list L and two integers s and f as arguments, and reverses the order of the nodes from the sth node to fth node, inclusive. The numbering begins at 1. Do not allocate additonal nodes.

There are two ways to solve this problem that rely on the same premise. If we are to reverse a linked list from the sth node to the fth node we need to reach that node first.

#+BEGIN_SRC java
Node current = head;
int counter = 1;
while(counter++ < s) {
    current = current.next;
}
#+END_SRC

Once we have found the node to begin reversing from, the variation in how we implement our answer shows itself.
The brute force method would be to keep track of the previous node as well when we find the node to begin reversing. This is so that we have an idea of where our new "subhead" is going to be.

We then begin reversing how you would normally reverse a linked list, except we stop until the counter is at f. We also assign a pointer, let's call it continueNode, to prev. We also assign a variable called tail to curr, as this will be where our list ends since it will be reversed.
#+BEGIN_SRC java
while(counter++ < f) {
    Node next = current.next;
    current.next = prev;
    prev = current;
    current = next;
}
#+END_SRC


After reversing the sublist we have two pointers: continueNode which points to the "subHead" and tail which is the end of the reversed sublist. Current is also at node after f, or f + 1. We now simply append pointers such that the list is correctly connected.

#+BEGIN_SRC java
// If the continueNode is not null then we set its next node to prev which is the new subHead.
if(continueNode != null) {
    continueNode.next = prev;
}
// If continueNode is null then that meanst the head of the list was also reversed.
else {
    head = prev;
}

// Append the end of the reversed sublist to f + 1.
tail.next = curr;
#+END_SRC

The implementation is below
,#+BEGIN_SRC java
Node reverseSublist(Node head, int s, int f) {
    if(head == null) return null;
    Node curr = head, prev = null;
    int counter = 1;

    while(counter++ < s) {
        prev = curr;
        curr = curr.next;
    }

    Node tail = curr, continueNode = prev, next = null;
    while(counter++ < f) {
        next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }

    if(continueNode != null){
        continueNode.next = prev;
    } else {
        head = prev;
    }

    tail.next = curr;
    return head;
}
#+END_SRC

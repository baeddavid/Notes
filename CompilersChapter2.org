#+TITLE: Compilers Chapter2
* Chapter 2
** 2.1
Syntax - Describes the proper form of its programs
Semantic - Defines what its programs means
** 2.2
For example, an if-else stament in java can have the form
    if (expression) statement else statement

    Rule: stmt --> if ( expr ) stmt else stmt

    The arrow can be read as "can have the form". Such a rule is called a production.
    Lexical elements such as if and the parentheses are called terminals.
    Variables like expr and strmt represent sequences of terminals and are called nonterminals.
*** 2.2.1
Context-free-grammar has four components:
    1. A set of terminal symbols, sometimes referred to as "tokens". The terminals are the elementary symbols of the language defined by the grammar.
    2. A set of nonterminals, sometimes called "syntactic variables." Each nonterminal represents a set of strings of terminals, in a manner we shall describe.
    3. A set of productions, where each production consists of a nonterminal, called the head or left side of the production, an arrow, and a sequence of terminals and/or nonterminaks, called the body or right side of the production. The intuitive intent of a production is to specify one of the written forms of a construct; if the head of a nonterminal represents a construct, then the body represens a written form of the construct.
    4. A designation of one of the nonterminals as the start symbol.
**** Example 2.1
ex1: 9 - 5 + 2
ex2: 3 - 1
ex3: 7

Since a plus or minus sign must appear between two digits, we refer to such expressions as lists of digits seperate by plus or minus signs.

list --> list + digit
list --> list - digit
list --> digit
digit --> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

We can then group the nonterminal list together such that we get the rule
list --> list + digit | list - digit | digit


A string of terminals is a sequence of zero or more terminals. The string of zero terminals is called 系, or the empty string.
*** 2.2.3 Parse Trees
If nonterminal A has a production A --> XYZ, then a parse tree may have an interior node labeled A with three children labaled X, Y, and Z, from left to right.

A parse tree has the following properties
    * The root is labeled by the start symbol.
    * Each leaf is labeled by a terminal or 系.
    * Each interior node is labeled by a nonterminal.
    * If A is the nonterminal labeling some interior node and X1, X2,..., Xn are the labels of the children of that node from left to right, then there must be a production A --> X1X2...Xn, In a special case if A --> 系 is a production, then a node labeled A may have a single child called 系.
*** 2.2.4 Ambiguity
A grammar can have more than one parse tree generating a given string of terminals. Such a grammar is said to be ambiguous. To show that a grammar is ambiguous, all we need to do is find a terminal string that is the yield of more than one parse tree.

Take the input: 9 - 5 + 2
And the production: string --> string + string | string - string | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

At a cursory glance the merging of 'list' and 'digit' seems like the right way to minimize the number of productions. However doing so carries consequences.

By having the current production we can actually create two parse trees, which translates to (9 - 5) + 2 and 9 - (5 + 2). This is a direct result of converting 'list + digit | list - digit'
*** 2.2.5 Associativity of Operators
By convention 9 + 5 + 2 os equivalent to (9 + 5) + 2. When an operand like 5 has operators to its left and right, conventions are needed for deciding which operator applies to that operand. We say that the + operator associates to the left, because an operand with plus signs on both sides of it belongs to the operator on the left.
*** 2.2.6 Precedence of Operators
We can create precedence for operations by creating productions. Let us say we want to create a grammar that handles basic arithmetic. We could do so with 3 productions.

factor --> digit | ( expr  )
term --> term * factor | term / factor | factor
expr --> expr + factor | exptr - factor | term
***
** 2.3 Syntax Directed Translation
Syntax-directed translation is done by attaching rules or program fragments to productions in a grammar.

expr --> expr1 + term

expr is the sum of the two subexpressions expr1 and term. We can translate expr by exploiting its structure as in the following pseudo-code:

    translate expr1;
    translate term;
    handle +;
*** 2.3.1 Postfix Notation
The postfix notation for an expression E can be defined inductively as follows:
    1. If E is a variable or constant, then the postfix notation for E is E itself.
    2. If E is an expreesion of the form 'E1 op E2', where 'op' is any binary operator, then the postfix notation for E is 'E`1 E`2 op', where E`1 and E`2 are the postfix notations for E1 and E2, respectively.
    3. If E is a parenthesized expression of the form (E1), then the postfix notation for E is the same as the postfix notation for E1.
*** 2.3.2 Syntheseized Attributes
A syntax-directed defintion associates
    1. With each grammar symbol, a set of attributes, and
    2. With each production, a set of semantic rules for computong the values of the attributes associated with the symbols appearing in the produciton.
***
